"use strict";
exports.__esModule = true;
exports.useModal = useModal;
exports.useAriaHidden = useAriaHidden;
var _hooks = require("@chakra-ui/hooks");
var _utils = require("@chakra-ui/utils");
var _reactUtils = require("@chakra-ui/react-utils");
var _ariaHidden = require("aria-hidden");
var _react = require("react");
var _modalManager = require("./modal-manager");
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
/**
 * Modal hook that manages all the logic for the modal dialog widget
 * and returns prop getters, state and actions.
 *
 * @param props
 */ function useModal(props) {
    var isOpen = props.isOpen, onClose = props.onClose, id = props.id, _props$closeOnOverlay = props.closeOnOverlayClick, closeOnOverlayClick = _props$closeOnOverlay === void 0 ? true : _props$closeOnOverlay, _props$closeOnEsc = props.closeOnEsc, closeOnEsc = _props$closeOnEsc === void 0 ? true : _props$closeOnEsc, _props$useInert = props.useInert, useInert = _props$useInert === void 0 ? true : _props$useInert, onOverlayClickProp = props.onOverlayClick, onEsc = props.onEsc;
    var dialogRef = _react.useRef(null);
    var overlayRef = _react.useRef(null);
    var _useIds = _hooks.useIds(id, "chakra-modal", "chakra-modal--header", "chakra-modal--body"), dialogId = _useIds[0], headerId = _useIds[1], bodyId = _useIds[2];
    /**
   * Hook used to polyfill `aria-modal` for older browsers.
   * It uses `aria-hidden` to all other nodes.
   *
   * @see https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/
   */ useAriaHidden(dialogRef, isOpen && useInert);
    /**
   * Hook use to manage multiple or nested modals
   */ _modalManager.useModalManager(dialogRef, isOpen);
    var mouseDownTarget = _react.useRef(null);
    var onMouseDown = _react.useCallback(function(event) {
        mouseDownTarget.current = event.target;
    }, []);
    var onKeyDown = _react.useCallback(function(event) {
        if (event.key === "Escape") {
            event.stopPropagation();
            if (closeOnEsc) onClose == null || onClose();
            onEsc == null || onEsc();
        }
    }, [
        closeOnEsc,
        onClose,
        onEsc
    ]);
    var _useState = _react.useState(false), headerMounted = _useState[0], setHeaderMounted = _useState[1];
    var _useState2 = _react.useState(false), bodyMounted = _useState2[0], setBodyMounted = _useState2[1];
    var getDialogProps = _react.useCallback(function(props1, ref) {
        if (props1 === void 0) props1 = {
        };
        if (ref === void 0) ref = null;
        return _extends({
            role: "dialog"
        }, props1, {
            ref: _reactUtils.mergeRefs(ref, dialogRef),
            id: dialogId,
            tabIndex: -1,
            "aria-modal": true,
            "aria-labelledby": headerMounted ? headerId : undefined,
            "aria-describedby": bodyMounted ? bodyId : undefined,
            onClick: _utils.callAllHandlers(props1.onClick, function(event) {
                return event.stopPropagation();
            })
        });
    }, [
        bodyId,
        bodyMounted,
        dialogId,
        headerId,
        headerMounted
    ]);
    var onOverlayClick = _react.useCallback(function(event) {
        event.stopPropagation();
        /**
     * Make sure the event starts and ends on the same DOM element.
     *
     * This is used to prevent the modal from closing when you
     * start dragging from the content, and release drag outside the content.
     *
     * We prevent this because it is technically not a considered "click outside"
     */ if (mouseDownTarget.current !== event.target) return;
        /**
     * When you click on the overlay, we want to remove only the topmost modal
     */ if (!_modalManager.manager.isTopModal(dialogRef)) return;
        if (closeOnOverlayClick) onClose == null || onClose();
        onOverlayClickProp == null || onOverlayClickProp();
    }, [
        onClose,
        closeOnOverlayClick,
        onOverlayClickProp
    ]);
    var getDialogContainerProps = _react.useCallback(function(props1, ref) {
        if (props1 === void 0) props1 = {
        };
        if (ref === void 0) ref = null;
        return _extends({
        }, props1, {
            ref: _reactUtils.mergeRefs(ref, overlayRef),
            onClick: _utils.callAllHandlers(props1.onClick, onOverlayClick),
            onKeyDown: _utils.callAllHandlers(props1.onKeyDown, onKeyDown),
            onMouseDown: _utils.callAllHandlers(props1.onMouseDown, onMouseDown)
        });
    }, [
        onKeyDown,
        onMouseDown,
        onOverlayClick
    ]);
    return {
        isOpen: isOpen,
        onClose: onClose,
        headerId: headerId,
        bodyId: bodyId,
        setBodyMounted: setBodyMounted,
        setHeaderMounted: setHeaderMounted,
        dialogRef: dialogRef,
        overlayRef: overlayRef,
        getDialogProps: getDialogProps,
        getDialogContainerProps: getDialogContainerProps
    };
}
/**
 * Modal hook to polyfill `aria-modal`.
 *
 * It applies `aria-hidden` to elements behind the modal
 * to indicate that they're `inert`.
 *
 * @param ref React ref of the node
 * @param shouldHide whether `aria-hidden` should be applied
 */ function useAriaHidden(ref, shouldHide) {
    _react.useEffect(function() {
        if (!ref.current) return undefined;
        var undo = null;
        if (shouldHide && ref.current) undo = _ariaHidden.hideOthers(ref.current);
        return function() {
            if (shouldHide) undo == null || undo();
        };
    }, [
        shouldHide,
        ref
    ]);
}
