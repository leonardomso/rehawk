"use strict";
exports.__esModule = true;
exports.parseGradient = parseGradient;
exports.gradientTransform = exports.globalSet = void 0;
function _wrapRegExp(re, groups) {
    _wrapRegExp = function _wrapRegExp1(re1, groups1) {
        return new BabelRegExp(re1, undefined, groups1);
    };
    var _RegExp = _wrapNativeSuper(RegExp);
    var _super = RegExp.prototype;
    var _groups = new WeakMap();
    function BabelRegExp(re1, flags, groups1) {
        var _this = _RegExp.call(this, re1, flags);
        _groups.set(_this, groups1 || _groups.get(re1));
        return _this;
    }
    _inherits(BabelRegExp, _RegExp);
    BabelRegExp.prototype.exec = function(str) {
        var result = _super.exec.call(this, str);
        if (result) result.groups = buildGroups(result, this);
        return result;
    };
    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {
        if (typeof substitution === "string") {
            var groups1 = _groups.get(this);
            return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function(_, name) {
                return "$" + groups1[name];
            }));
        } else if (typeof substitution === "function") {
            var _this = this;
            return _super[Symbol.replace].call(this, str, function() {
                var args = [];
                args.push.apply(args, arguments);
                if (typeof args[args.length - 1] !== "object") args.push(buildGroups(args, _this));
                return substitution.apply(this, args);
            });
        } else return _super[Symbol.replace].call(this, str, substitution);
    };
    function buildGroups(result, re1) {
        var g = _groups.get(re1);
        return Object.keys(g).reduce(function(groups2, name) {
            groups2[name] = result[g[name]];
            return groups2;
        }, Object.create(null));
    }
    return _wrapRegExp.apply(this, arguments);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper1(Class1) {
        if (Class1 === null || !_isNativeFunction(Class1)) return Class1;
        if (typeof Class1 !== "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class1)) return _cache.get(Class1);
            _cache.set(Class1, Wrapper);
        }
        function Wrapper() {
            return _construct(Class1, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class1.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _setPrototypeOf(Wrapper, Class1);
    };
    return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) _construct = Reflect.construct;
    else _construct = function _construct1(Parent1, args1, Class1) {
        var a = [
            null
        ];
        a.push.apply(a, args1);
        var Constructor = Function.bind.apply(Parent1, a);
        var instance = new Constructor();
        if (Class1) _setPrototypeOf(instance, Class1.prototype);
        return instance;
    };
    return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
    } catch (e) {
        return false;
    }
}
function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf1(o1, p1) {
        o1.__proto__ = p1;
        return o1;
    };
    return _setPrototypeOf(o, p);
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf1(o1) {
        return o1.__proto__ || Object.getPrototypeOf(o1);
    };
    return _getPrototypeOf(o);
}
var directionMap = {
    "to-t": "to top",
    "to-tr": "to top right",
    "to-r": "to right",
    "to-br": "to bottom right",
    "to-b": "to bottom",
    "to-bl": "to bottom left",
    "to-l": "to left",
    "to-tl": "to top left"
};
var valueSet = new Set(Object.values(directionMap));
var globalSet = new Set([
    "none",
    "-moz-initial",
    "inherit",
    "initial",
    "revert",
    "unset"
]);
exports.globalSet = globalSet;
var trimSpace = function trimSpace1(str) {
    return str.trim();
};
function parseGradient(value, theme) {
    var _regex$exec$groups, _regex$exec;
    if (value == null || globalSet.has(value)) return value;
    var regex = /*#__PURE__*/ _wrapRegExp(/(^[\x2DA-Za-z]+)\(((.*))\)/g, {
        type: 1,
        values: 2
    });
    var _ref = (_regex$exec$groups = (_regex$exec = regex.exec(value)) == null ? void 0 : _regex$exec.groups) != null ? _regex$exec$groups : {
    }, type = _ref.type, values = _ref.values;
    if (!type || !values) return value;
    var _type = type.includes("-gradient") ? type : type + "-gradient";
    var _values$split$map$fil = values.split(",").map(trimSpace).filter(Boolean), maybeDirection = _values$split$map$fil[0], stops = _values$split$map$fil.slice(1);
    if ((stops == null ? void 0 : stops.length) === 0) return value;
    var direction = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;
    stops.unshift(direction);
    var _values = stops.map(function(stop) {
        // if stop is valid shorthand direction, return it
        if (valueSet.has(stop)) return stop; // color stop could be `red.200 20%` based on css gradient spec
        var _stop$split = stop.split(" "), _color = _stop$split[0], _stop = _stop$split[1]; // else, get and transform the color token or css value
        var key = "colors." + _color;
        var color = key in theme.__cssMap ? theme.__cssMap[key].varRef : _color;
        return _stop ? [
            color,
            _stop
        ].join(" ") : color;
    });
    return _type + "(" + _values.join(", ") + ")";
}
var gradientTransform = function gradientTransform1(value, theme) {
    return parseGradient(value, theme != null ? theme : {
    });
};
exports.gradientTransform = gradientTransform;
